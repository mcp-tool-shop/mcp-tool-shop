#!/usr/bin/env node

/**
 * Generate or update a GitHub issue in mcp-tool-registry from cleanup.json.
 *
 * Reads site/src/data/registry/cleanup.json and either creates or updates
 * an issue titled "Registry cleanup: archived/missing tools" in the upstream
 * registry repo.
 *
 * Env:
 *   GITHUB_TOKEN — required for API calls
 *   REGISTRY_REPO — target repo (default: mcp-tool-shop-org/mcp-tool-registry)
 *   DRY_RUN — set to "1" to print body without creating issue
 */

import fs from "node:fs";
import path from "node:path";

const REPO_ROOT = process.cwd();
const REGISTRY_DATA_DIR = path.join(REPO_ROOT, "site", "src", "data", "registry");
const CLEANUP_PATH = path.join(REGISTRY_DATA_DIR, "cleanup.json");
const META_PATH = path.join(REGISTRY_DATA_DIR, "meta.json");

const TOKEN = process.env.GITHUB_TOKEN || "";
const REGISTRY_REPO =
  process.env.REGISTRY_REPO || "mcp-tool-shop-org/mcp-tool-registry";
const DRY_RUN = process.env.DRY_RUN === "1";
const ISSUE_TITLE = "Registry cleanup: archived/missing tools";
const ISSUE_LABEL = "hygiene";

function readJson(p) {
  if (!fs.existsSync(p)) return null;
  return JSON.parse(fs.readFileSync(p, "utf8"));
}

function writeJson(p, obj) {
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, JSON.stringify(obj, null, 2) + "\n", "utf8");
}

/** Write cleanup issue number + URL back into meta.json so the footer can link to it */
function updateMeta(issueNumber, issueUrl) {
  const meta = readJson(META_PATH) || {};
  meta.cleanupIssueNumber = issueNumber;
  meta.cleanupIssueUrl = issueUrl;
  writeJson(META_PATH, meta);
  console.log(`Updated meta.json with cleanup issue #${issueNumber}`);
}

const ISSUE_MARKER = "<!-- REGISTRY_CLEANUP_ISSUE -->";

function buildIssueBody(cleanup) {
  const lines = [];

  lines.push(
    ISSUE_MARKER,
    "",
    "## Registry Cleanup Report",
    "",
    `Generated at: \`${cleanup.generatedAt}\``,
    `Total issues: **${cleanup.totalIssues}**`,
    "",
    "This issue is auto-generated by the [mcp-tool-shop sync](https://github.com/mcp-tool-shop/mcp-tool-shop) workflow.",
    "It reflects discrepancies between `registry.json` and the actual GitHub org state.",
    ""
  );

  if (cleanup.archived.length > 0) {
    lines.push(
      `### Archived repos (${cleanup.archived.length})`,
      "",
      "These tools point to repos that have been **archived** on GitHub.",
      "Action: remove from `registry.json` or add `\"deprecated\": true`.",
      "",
      "| Registry ID | Repo | Suggested action |",
      "|---|---|---|"
    );
    for (const item of cleanup.archived) {
      lines.push(
        `| \`${item.registryId}\` | ${item.repoName} | ${item.action} |`
      );
    }
    lines.push("");
  }

  if (cleanup.missing.length > 0) {
    lines.push(
      `### Missing repos (${cleanup.missing.length})`,
      "",
      "These tools have **no matching repo** in the org (not archived, just absent).",
      "Action: verify the repo URL in `registry.json` or remove the entry.",
      "",
      "| Registry ID | Expected repo | Suggested action |",
      "|---|---|---|"
    );
    for (const item of cleanup.missing) {
      lines.push(
        `| \`${item.registryId}\` | ${item.repoName} | ${item.action} |`
      );
    }
    lines.push("");
  }

  if (cleanup.aliases.length > 0) {
    lines.push(
      `### Active aliases (${cleanup.aliases.length})`,
      "",
      "These are workarounds for registry ID / repo name mismatches.",
      "Preferred fix: update the registry `id` or `repo` URL to match, then retire the alias.",
      "",
      "| Registry ID | Actual repo name | Reason |",
      "|---|---|---|"
    );
    for (const item of cleanup.aliases) {
      lines.push(
        `| \`${item.registryId}\` | ${item.repoName} | ${item.reason} |`
      );
    }
    lines.push("");
  }

  lines.push(
    "---",
    "",
    "Once these items are resolved in the upstream registry, re-running the",
    "marketing site sync will clear them from the cleanup queue automatically."
  );

  return lines.join("\n");
}

async function ghApi(method, endpoint, body = null) {
  const url = `https://api.github.com${endpoint}`;
  const headers = {
    Accept: "application/vnd.github+json",
    "User-Agent": "mcp-tool-shop-cleanup",
  };
  if (TOKEN) headers["Authorization"] = `Bearer ${TOKEN}`;

  const opts = { method, headers };
  if (body) {
    headers["Content-Type"] = "application/json";
    opts.body = JSON.stringify(body);
  }

  const res = await fetch(url, opts);
  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`GitHub API ${res.status} ${method} ${endpoint}\n${text}`);
  }
  return res.json();
}

async function findExistingIssue() {
  // Search for open issues — match by stable HTML marker first, then title
  const issues = await ghApi(
    "GET",
    `/repos/${REGISTRY_REPO}/issues?state=open&labels=${ISSUE_LABEL}&per_page=20`
  );
  // Primary: find by marker (survives title renames)
  const byMarker = issues.find(
    (i) => i.body && i.body.includes(ISSUE_MARKER)
  );
  if (byMarker) return byMarker;
  // Fallback: match by title
  return issues.find((i) => i.title === ISSUE_TITLE) || null;
}

async function main() {
  const cleanup = readJson(CLEANUP_PATH);
  if (!cleanup) {
    console.log("No cleanup.json found — nothing to report.");
    return;
  }

  if (cleanup.totalIssues === 0) {
    console.log("Cleanup queue is empty — no issues to report.");
    return;
  }

  const body = buildIssueBody(cleanup);

  if (DRY_RUN) {
    console.log("=== DRY RUN — Issue body ===");
    console.log(`Title: ${ISSUE_TITLE}`);
    console.log(`Repo: ${REGISTRY_REPO}`);
    console.log(`Label: ${ISSUE_LABEL}`);
    console.log("---");
    console.log(body);
    return;
  }

  if (!TOKEN) {
    console.error("GITHUB_TOKEN required for creating issues. Use DRY_RUN=1 to preview.");
    process.exit(1);
  }

  // Check if issue already exists
  const existing = await findExistingIssue();

  if (existing) {
    // Update existing issue
    await ghApi("PATCH", `/repos/${REGISTRY_REPO}/issues/${existing.number}`, {
      body,
    });
    console.log(
      `Updated existing issue #${existing.number}: ${existing.html_url}`
    );
    updateMeta(existing.number, existing.html_url);
  } else {
    // Create new issue
    const issue = await ghApi("POST", `/repos/${REGISTRY_REPO}/issues`, {
      title: ISSUE_TITLE,
      body,
      labels: [ISSUE_LABEL],
    });
    console.log(`Created issue #${issue.number}: ${issue.html_url}`);
    updateMeta(issue.number, issue.html_url);
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
